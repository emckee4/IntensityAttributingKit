
import UIKit

public protocol IntensityTransforming {
    static var schemeName:String {get}
    ///stepCount indicates the number of divisions in intensity rendering which are actually rendered. This value allows longer stretches of similar attributes to be consolodated before being passed to the internal TextKit processors.
    static var stepCount:Int {get}
    ///takes prior text inserts IntensityAttributes and compares it to the typingAttributes generated by the built in processes to detect if the user has selected bold or italic options, while also updating the intensityAttributes for the new value in the current rendering scheme
    //func updateIntensityAttributesInScheme(lastIntensityAttributes lastIA:IntensityAttributes, providedAttributes:[String:AnyObject], intensity:Float)->IntensityAttributes
    //func typingAttributesForScheme(intensityAttributes:IntensityAttributes, retainedKeys:[String:AnyObject]?)->[String:AnyObject]
    static func generateSampleFromText(text:String, size:CGFloat)->NSAttributedString

    static func nsAttributesForIntensityAttributes(intensity intensity:Int,baseAttributes:IABaseAttributes)->[String:AnyObject]
    static func nsAttributesForBinsAndBaseAttributes(bin bin:Int,baseAttributes:IABaseAttributes)->[String:AnyObject]
    
}

///Default implementations for the mutable and immutable transformations. These each rely on nsAttributesForIAAttributes to do the scheme specific work.
public extension IntensityTransforming {
/*    func transformWithScheme(targetIAString attString: NSAttributedString) -> NSAttributedString {
        let mutAS = NSMutableAttributedString(attributedString: attString)
        transformWithSchemeInPlace(targetIAString: mutAS)
        return NSAttributedString(attributedString: mutAS)
    }
    
    func transformWithSchemeInPlace(targetIAString attString: NSMutableAttributedString) {
        attString.enumerateAttributesInRange(NSRange(location: 0, length: attString.length), options: NSAttributedStringEnumerationOptions.init(rawValue: 0)) { (attrs:[String : AnyObject], range:NSRange, stop) -> Void in
            let partedAtts = IATags.partitionAttributeDict(attrs)
            var newAtts:[String:AnyObject] = self.nsAttributesForIAAttributes(partedAtts.iaDict)
            //newAtts[IATags.IAKeys] = (partedAtts.iaDict as [String:AnyObject])
            var newIADict:[String:AnyObject] = partedAtts.iaDict
            newIADict[IATags.IACurrentRendering] = Self.schemeName
            newAtts[IATags.IAKeys] = newIADict
            if partedAtts.attachment != nil {
                newAtts[NSAttachmentAttributeName] = partedAtts.attachment!
            }
            if partedAtts.anyLink != nil {
                newAtts[NSLinkAttributeName] = partedAtts.anyLink!
            }
            
            //(newAtts[IATags.IAKeys] as! [String:AnyObject])[IATags.IACurrentRendering] = Self.schemeName //[IATags.IACurrentRendering] = Self.schemeName
            //var newCombinedAttrs:[String:AnyObject] = partedAtts.iaDict
//            for (key,value) in newNSAtts {
//                newCombinedAttrs[key] = value
//            }
//            if partedAtts.attachment != nil {
//                newCombinedAttrs[NSAttachmentAttributeName] = partedAtts.attachment!
//            }
//            if partedAtts.anyLink != nil {
//                newCombinedAttrs[NSLinkAttributeName] = partedAtts.anyLink!
//            }
//            newCombinedAttrs[IATags.IACurrentRendering] = Self.schemeName
//            ///check if the attributes still match after the transform. If so we don't need to setAttributes on this entry


            
            if newAtts.count != attrs.count || newIADict[IATags.IACurrentRendering] as? String != partedAtts.iaDict[IATags.IACurrentRendering] as? String {
                attString.setAttributes(newAtts, range: range)
            }
            
//            if (newAtts as! [String:NSObject]) != (attrs as! [String:NSObject])  {
//                attString.setAttributes(newAtts, range: range)
//            }
        }
    }
    
    public func typingAttributesForScheme(intensityAttributes:IntensityAttributes, retainedKeys:[String:AnyObject]? = nil)->[String:AnyObject]{
        //want just nsAttributes plus the iakeys dict
        var atts = self.nsAttributesForIAAttributes(intensityAttributes.asAttributeDict)
        atts[IATags.IAKeys] = intensityAttributes.asAttributeDict
        if retainedKeys != nil {
            for (key,value) in retainedKeys! {
                atts[key] = value
            }
        }
        return atts
    }
*/
    ///transforms provided using the transformer while varying the intensity linearly over the length of the sample
    public static func generateSampleFromText(text:String, size:CGFloat)->NSAttributedString{
        let charCount:Int = text.characters.count
        let baseAttributes = IABaseAttributes(size:Int(size),options: [])
        guard charCount > 0 else {return NSAttributedString()}
        let mutableAS:NSMutableAttributedString = NSMutableAttributedString(string: text)
        for i in 0..<charCount {
            let thisIntensity:Int = Int((Float(i) / Float(charCount) + 0.001) * 100)
            let nsAttributes = self.nsAttributesForIntensityAttributes(intensity:thisIntensity, baseAttributes: baseAttributes)
            mutableAS.setAttributes(nsAttributes, range: NSRange(location: i, length: 1))
        }
        return mutableAS
    }
    
    public static func nsAttributesForIntensityAttributes(intensity intensity:Int,baseAttributes:IABaseAttributes)->[String:AnyObject]{
        //use existing code predominantly for this
        let weightBin = min((binNumberForSteps(intensity, steps:stepCount) + (baseAttributes.bold ? 1 : 0)), stepCount)
        return self.nsAttributesForBinsAndBaseAttributes(bin: weightBin, baseAttributes: baseAttributes)
    }
    
}

